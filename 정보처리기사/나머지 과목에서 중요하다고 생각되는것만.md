1. 디자인 패턴
	- 생성 패턴
		- Abstract Factory(추상 팩토리): 구체적인 클래스에 의존하지 않고 ==서로 연관되거나 의존적인 객체들의 조합==을 만드는 인터페이스를 제공
		- Builder: 복잡한 인스턴스를 ==조립해서 단계별==로 만드는 구조
		- Factory Method: 상위 클래스에서 ==객체를 생성하는 인터페이스를 정의==하고 ==하위 클래스에서 인스턴스를 생성==하는 패턴
		- Prototype(프로토타입): ==기존 객체를 복제해서 새 객체를 생성==할 수 있도록 하는 패턴
		- Singleton(싱글턴): 전역변수 사용x, ==객체 하나만 생성==하도록 하며, 생성된 객체를 어디서든지 참조할수 있음. ![[Pasted image 20230928002301.png]]
	- 구조 패턴
		- Adapter(어댑터): 기존에 생성된 클래스를 재사용할 수 있도록 ==중간에서 맞춰주는 역할==을 하는 인터페이스를 만드는 패턴
		- Bridge(브리지): ==추상과 구현을 분리==해서 결합도를 낮춘 패턴
		- Composite(복합체): ==개별 객체와 복합 객체==를 클라이언트에서 동일하게 사용하도록 하는 패턴, 트리 구조
		- Decorator: ==소스를 변경하지 않고 기능을 확장==하는 패턴
		- Facade: 하나의 인터페이스를 통해 ==느슨한 결합==을 제공하는 패턴
		- Flyweight(플라이웨이트): ==대량의 작은 객체==들을 ==공유==하는 패턴
		- Proxy: ==대리인이 대신 그 일을 처리==하는 패턴![[Pasted image 20230928002215.png]]
	- 행위 패턴
		- Command(커맨드): ==요구사항을 객체로 캡슐화==해 파라미터로 넘기는 패턴
		- Observer: 상태가 변할때 ==의존자들에게 알리==고 자동으로 업데이트하는 패턴
		- Templete method: ==상위 클래스에서는 추상적==, ==하위 클래스에서는 구체적인 내용을 결정==하는 디자인 패턴
		- Mediator(중재자): 객체의 수가 너무 많아져 통신이 복잡해지면 ==중간에서 이를 통제하고 지시 역할==
		- Interpreter(통역사): ==다양한 언어 구문을 해석==할 수 있게 만드는 패턴
		- Iterator(반복자): 객체 간 ==상호작용을 캡슐화==한 패턴, 요소들의 기본 표현을 노출하지 않고 하나씩 순회
		- State(상태): 객체 상태를 ==캡슐화해서 클래스화 함 그것을 참조==하게 하는 방식
		- Visitor(방문자): 처리구조를 분리하여 ==별도의 클래스를 만들어== 놓고 해당 클래스의 메서드가 각 ==클래스를 돌아다니며 특정 작업을 수행==하도록 만드는 패턴
		- Strategy(전략): 알고리즘 군을 정의하고 같은 알고리즘을 ==각각 하나의 클래스로 캡슐화==한 후, ==필요할때 교환==해서 사용할 수 있게 하는 패턴
		- Memento: 클래스 설계 관점에서 ==객체의 정보를 저장할 필요가 있을 때== 적용하는 디자인 패턴
		- Chain of Responsibility(책임 연쇄): 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어있어있을떄 연결 변경이 불가능, 이를 동적으로 연결한 경우 다르게 처리할 수 있도록 하는 디자인 패턴 ![[Pasted image 20230928002452.png]]![[Pasted image 20230928002518.png]]
2. 응집도 

| 강한순서  |  기순교절시논우응 높은게 좋다 |
|---|---|
|기능적 응집도  |==모듈 내부의 모든 기능 요소들이 단일== 문제와 연관되어 수행될 경우의 응집도|
|순차적 응집도  |모듈 내 하나의 ==활동으로부터 나온 출력 데이터==를 ==그 다음 활동의 입력 데이터==로 사용할 경우의 응집도|
|교환적 응집도  |==동일한 입력과 출력을 사용==하여 ==서로 다른 기능을 수행하는 구성 요소들이 모였==을 경우의 응집도|
|절차적 응집도  |모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 ==순차적으로 수행할 경우==의 응집도|
|시간적 응집도  |==특정 시간에 처리되는== 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도|
|논리적 응집도  |==유사한 성격을 갖거나 특정 형태==로 분류되는 처리 요소들로 ==하나의 모듈이 형성==되는 경우의 응집도|
|우연적 응집도  |모듈 내부의 각 구성 요소들이 서로 ==관련 없는 요소로만 구성==된 경우의 응집도|

3. 결합도 

|강한 순서 |내공외제스자결 낮은게 좋음 |
|---|---|---|
|**내용 결합도 (Content Coupling)** |==한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료==를 직접 참조하거나 수정(public 속성)할 때의 결합도
|**공통 결합도 (Common Coupling)**  |==공유되는 공통 데이터 영역(전역변수==)을 여러 모듈이 사용할 때의 결합도
|**외부 결합도 (External Coupling)**|어떤 모듈에서 ==선언한 데이터(변수)를 외부의 다른 모듈==에서 참조할 때의 결합도
|**제어 결합도 (Control Coupling)**|어떤 모듈이 ==다른 모듈 내부의 논리적인 흐름을 제어==하기 위해 제어 신로를 통신하거나 제어 요소(Flag)를 전달하는 결합도|
|**스탬프 결합도 (Stamp Coupling)** |모듈 간의 ==인터페이스로 배열이나 레코드 등의 자료 구조==가 전달될 때의 결합도
|**자료 결합도 (Data Coupling)**|모듈 간의 인터페이스가 ==자료 요소로만 구성==될 때의 결합도|

4. SOLID 원칙
	- SRP (단일 책임 원칙): 한 클래스는 하나의 책임
	- OCP (개방 폐쇄 원칙): 확장에는 열림, 변경에는 닫힘
	- LSP (리스코프 치환 원칙): 하위 클래스는 어디서나 자신의 상위클래스 인스턴스로 바꿀 수 있다.
	- ISP (인터페이스 분리 원칙): 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다.
	- DIP (의존관계 역전 원칙): 추상화의 의존, 구체화에 의존하면 안됨

5. 호스트 주소, 서브넷 마스크, 네트워크 주소 계산
	- 호스트 주소와 서브넷 마스크를 2진수로 바꾸고 AND연산 = 네트워크 주소
	- 호스트 주소 개수는 서브넷 맨뒤 2진수 바꾸고 계산
	  ex) 255.255.255.192 : 11000000 
	  서브넷 개수 : 1의 개수 -> 2의2승 = 4개
	  호스트 주소 개수 : 0의 개수 -> 2의6승 = 64개
	  네트워크 주소와 브로드캐스트 주소를 뺀 64 -2 = 62개

6. 형상관리
	↘️ 소프트웨어의 개발 과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동
	- 형상 관리 절차 (식통감기)
		1. 형상 식별: 관리대상에 이름, 번호 부여, 계층 구조로 구분
		2. 형상 통제: 현재의 기준선이 잘 반영될 수 있도록 조정
		3. 형상 감사: 무결성 평가하기 위해 확인
		4. 형상 기록: 보고서 작성하는

7. 3A
	- 계정관리: Accounting: 기록을 남기는 활동
	- 인증: Authentication: 증명하는 과정
	- 인가: Authorization: 권리를 부여하는 행위

1) 캡슐화(Encapsulation)  
	- 데이터와 함수를 하나로 묶는 것을 의미  
	- 재사용성 증가, 오류 파급 효과 감소  
	- 인터페이스가 단순해짐, 객체 간 결합도가 낮아짐  
2) 정보 은닉(Information hiding)  
	- 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해 접근  
	- 다른 객체에게 주는 영향을 감소시킴  
3) 추상화(Abstraction)  
	- 불필요한 부분을 생략하고 중요한 것에만 중점을 두어 모델화  
4) 상속성(Inheritance)  
	- 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받음  
	- 상위 클래스에 정의된 속성을 재정의하지 않아도 된다.  
	- 새로운 속성과 연산을 추가하여 사용 가능  
	- 다중 상속성(Multiple Inheritance) : 한 개의 클래스가 두 개 이상의 상위 클래스로부터 상속  
5) 다형성(Polymorphism)  
	- 같은 함수, 기능에 대해 다른 정의를 통해 각 클래스가 다른 행동을 할 수 있게 해줌  
	- Overloading : 같은 이름을 가진 함수지만 인자가 달라 각기 다른 인자에 따라 함수를 선택해 수행  
	- Overriding : 상위 클래스로부터 상속받은 함수들을 다르게 구현하여 사용

- UML : 객체지향 소프트웨어 개발 과정에서 산출물을 명세화, 시각화, 문서화할 때 사용하는 모델링 기술과 방법론을 통합해서 만든 표준화된 범용 모델링 언어이다.
- UML 특징(가구명문)
	- 가시화 언어
	- 구축 언어
	- 명세화 언어
	- 문서화 언어
- UML 구성요소(사관다)
	- 사물
	- 관계
	- 다이어그램
- UML 다이어그램
	- 구조적 다이어그램/ 정적 다이어그램 (클객 컴배 복패)
		- 클래스 다이어그램: 클래스 사이의 관계를 표현하는 UML을 이용한 정적 모델링
		- 객체 다이어그램: 클래스에 속한 객체들, 인스턴스를 특정 시점의 객채와 객체 사이의 관계 표현
		- 컴포넌트 다이어그램: 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현
		- 배치 다이어그램: 컴포넌트 사이의 종속성을 표현, 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현
		- 복합체 구조 다이어그램: 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부구조를 표현
		- 패키지 다이어그램: 유스케이스나 클래스 등의 모델 요소들은 그룹화한 패키지들의 관계를 표현
	- 행위적 다이어그램/ 동적 다이어그램 (유시커 상활타)
		- 유스케이스 다이어그램: 시스템이 제공하고 있는 기능과 그와 관련된 외부 요소들을 사용자의 입장에서 표현하는 다이어그램
			- 구성요소 : 유스케이스  + 액터 + 시스템 + 시나리오 + 이벤트의 흐름
			- 관계
				- 포함관계
				- 확장관계
				- 일반화 관계
		- 시퀀스 다이어그램: 객체 간 동적 상호작용을 시간적 개념으로 메세지 흐름을 이용해서 표현하는 다이어그램
			- 구성요소 : 액터 + 객체 + 생명선 + 활성화 + 메세지
		- 커뮤니케이션 다이어그램: 객체들이 주고받는 메세지와 객체 간의 연관을 표현하는 다이어그램
		- 상태 다이어그램: 하나의 객체가 자신이 속한 클래스의 상태변화 혹은 다른 객체간의 상호작용에 따라 상태가 변화하는 것을 표현하는 다이어그램
		- 활동 다이어그램: 시스템이 어떤 기능을 수행하는지 처리의 흐름을 순서로 표현한 다이어그램
		- 타이밍 다이어그램: 객체 상태 변화와 시간 제약을 명시적으로 표현하는 다이어그램
- 